<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[equals与hashcode分析]]></title>
    <url>%2F2019%2F09%2F25%2Fequals%E4%B8%8Ehashcode%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[我们经常在面经中看到这样的问题，为什么重写equals方法就一定要重写hashcode方法。本文就是分析这个问题。 在阿里巴巴java开发手册中就给出了这样的规则。 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：1） 只要重写 equals，就必须重写 hashCode。2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 看下面的代码，有什么问题吗？ 1234567891011121314151617181920212223242526272829import java.util.HashMap;import java.util.Map;public class Five &#123; public static class Person&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; &#125; public static void main(String[] args) &#123; Map&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(new Person(&quot;sisi&quot;, 18), 9); map.put(new Person(&quot;lili&quot;, 12), 2); map.put(new Person(&quot;lili&quot;, 12), 1); System.out.println(map.toString()); System.out.println(map.get(new Person(&quot;sisi&quot;, 18))); System.out.println(map.get(new Person(&quot;lili&quot;, 12))); &#125; &#125; 运行后的结果为： 123&#123;com.chr.binarysearch.Five$Person@7852e922=1, com.chr.binarysearch.Five$Person@15db9742=9, com.chr.binarysearch.Five$Person@6d06d69c=2&#125;nullnull 我们不难看出new Person(“lili”, 12)这个对象作为key，竟然加入到HashMap中两次，违背了HashMap中key是唯一的原则。我们可以插入System.out.println(new Person(“lili”, 12).hashcode());来获得两次添加到HashMap中对象的hashcode的值。 122018699554118352462 虽然对象相同，但是hashcode值不同，这也解释了通过对象获取value值为null。 那么该如何保证自定义类对象作为key的唯一性？ 重写equals方法和hashcode方法。 在java核心技术 卷1中给出了编写一个完美的equals方法的建议： 12345678910111213141516171819public boolean equals(Object otherObj)&#123; 1)检测this与otherObj是否引用同一个对象： if(this == otherObj)&#123; return true; &#125; 2)检测otherObj是否为null，如果为null，返回false。 if(otherObj == null)&#123; return false; &#125; 3)比较this与otherObj是否属于同一个类。 if(getClass() != otherObj.getClass())&#123; return false; &#125; 4)将otherObj转换成相应的类型变量： ClassName other = (ClassName)otherObj; 5)开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。 return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2);&#125; 这是我自己重写的equals方法 12345678910111213141516public boolean equals(Object otherObj) &#123; if(this == otherObj) &#123; return true; &#125; if(otherObj == null) &#123; return false; &#125; if(!(otherObj instanceof Person)) &#123; return false; &#125; Person other = (Person)otherObj; return Objects.equals(name, other.name) &amp;&amp; age == other.age; &#125; &#125; 之所以用objects.equals(name,other.name);防止空指针异常。 重写hashcode方法 123public int hashCode() &#123; return Objects.hash(name,age); &#125;]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序数组转换为二叉搜索树]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 —–题目分析—– 二叉搜索树的中序遍历就是一个按照升序排列的有序数组，且根节点的 下标为（start+end）/2，start:数组第一个元素的下标 end:数组最后一个元素的下标 —–代码—– 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums==null)&#123; return null; &#125;else&#123; TreeNode temp=creatBinaryTree(nums,0,nums.length-1 ); return temp; &#125; &#125; public TreeNode creatBinaryTree(int[] nums,int start,int end)&#123; if(start&gt;end)&#123; return null; &#125; if(start==end)&#123; return new TreeNode(nums[start]); &#125; int mid=(start+end)/2; TreeNode root=new TreeNode(nums[mid]); root.left=creatBinaryTree(nums,start,mid-1); root.right=creatBinaryTree(nums,mid+1,end); return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[—–题目描述—–在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 —–题目分析—–1、这是一个有序的数组，可以通过数组的每行的最后一个值与目标值进行比较，如果目标值等于该值，直接返回。如果大于该值，进入下一行。如果小于该值，循环遍历查找。 2、需判断数组是否为空，特别注意[[]]这个数组。 —–代码—–1234567891011121314151617181920212223public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array.length==0||array[0].length==0)&#123; return false; &#125; for(int i=0;i&lt;array.length;i++)&#123; if(array[i][array[i].length-1]==target)&#123; return true; &#125;else&#123; if(array[i][array[i].length-1]&lt;target)&#123; continue; &#125;else&#123; for(int j=0;j&lt;array[i].length-1;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false; &#125;&#125; 运行时间：181ms 占用内存：17432k]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中两种比较器的实现]]></title>
    <url>%2F2019%2F07%2F20%2Fjava%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[—–比较器的两种实现方式—–在我们使用数组或容器的时候，经常需要使用排序，特别是根据需求自定义排序，Java给了我们两种比较器实现的接口。 一、Comparable接口它 是java.lang包下的一个接口，需要实现int compareTo(T o)方法 主代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class student implements Comparable&lt;student&gt;&#123; private String name; private int age; public student(int age) &#123; this.age = age; &#125; public student(String name, int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "我的名字是："+name+"我的年龄是：" + age; &#125; @Override public int compareTo(student o) &#123; int num=this.name.length()-o.name.length(); int num1=num==0?(this.name).compareTo(o.name):num; int num2=num1==0?this.age-o.age:num1; return num2; &#125;&#125; 测试代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; List&lt;student&gt; list = new ArrayList&lt;&gt;(); student s1=new student("LiLi",12); student s2=new student("HuaHua",9); student s3=new student("MingMing",23); student s4=new student("MeiMei",17); list.add(s1); list.add(s2); list.add(s3); list.add(s4); Collections.sort(list); Iterator&lt;student&gt; it=list.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 二、Comparator接口主代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class student&#123; private String name; private int age; public student(int age) &#123; this.age = age; &#125; public student(String name, int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "我的名字是："+name+"我的年龄是：" + age; &#125;&#125;//Comparator接口的实现类public class StudentComparator implements Comparator&lt;student&gt; &#123; public int compare(student s1, student s2) &#123; int num=s1.getName().length()-s2.getName().length(); int num1=num==0?s1.getName().compareTo(s2.getName()):num; int num2=num1==0?s1.getAge()-s2.getAge():num1; return num2; &#125;&#125; 测试代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; List&lt;student&gt; list = new ArrayList&lt;&gt;(); student s1=new student(&quot;LiLi&quot;,12); student s2=new student(&quot;HuaHua&quot;,9); student s3=new student(&quot;MingMing&quot;,23); student s4=new student(&quot;MeiMei&quot;,17); list.add(s1); list.add(s2); list.add(s3); list.add(s4); Collections.sort(list, new StudentComparator()); Iterator&lt;student&gt; it=list.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 三、比较1、Comparable是属于java.lang包下的接口，而Comparator是属于java.util包下的接口。 2、实现方式不同，Comparable接口主类（实现需求的类）可以直接实现，而不需要重新创建新的实现类，而Comparator接口需要创建新的实现类。 3、测试类的调用方式不同，Comparable接口使用的是 Collections.sort(list); 而Comparator接口使用的是 Collections.sort(list, new StudentComparator()); 4、前三点都是不同点，第四点是相同点。怎么判断正序或反序。 如果this.age&gt;o.age(this.age-o.age&gt;0)的情况下，返回的值为正值，即按正序排列，返回的值为负值，即按反序排列。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F07%2F14%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[—–题目描述—–给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 —–题目分析—–1、两个非空链表不同时为空。 2、因为是加法必须要考虑进位，且进位的可能性只有两种0或1。 3、一个链表只要有头节点就能将其表示出来 4、得到的新链表必须有pre和cur两个节点共同完成。 代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pre=new ListNode(0); ListNode p=l1; ListNode q=l2; ListNode cur=pre; int carry=0; while(p!=null||q!=null)&#123; int x=p!=null?p.val:0; int y=q!=null?q.val:0; int sum=x+y+carry; carry=sum/10; cur.next=new ListNode(sum%10); cur=cur.next; if(p!=null)&#123; p=p.next; &#125; if(q!=null)&#123; q=q.next; &#125; &#125; if(carry==1)&#123; cur.next=new ListNode(1); &#125; return pre.next; &#125;&#125; 注意:为什么返回的是pre.next(应为其指向的是链表的第一节点，值为两个链表节点和的第一个值，pre节点的值为0)，而为什么只使用cur一个节点？（cur在while循环中指向的节点早已偏离了第一个节点）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表一个有趣的问题]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 在学习单链表的时候发现一个有趣的问题，看下面的代码一与代码二，在逻辑上似乎相同，但是执行的结果却不相同，究竟是为什么？ 代码一： 12345678910111213141516171819public class SingleLinkedList &#123; public static void main(String[] args) &#123; Node n1=new Node(1); Node n2=new Node(2); Node n3=new Node(3); Node n4=new Node(4); n1.next=n2; n2.next=n3; n3.next=n4; Node temp=n1; while(temp.next!=null)&#123; temp=temp.next; &#125; temp.next=new Node(10); System.out.println(n1.next.next.next.next.val); &#125;&#125; 代码二： 12345678910111213141516171819public class SingleLinkedList &#123; public static void main(String[] args) &#123; Node n1=new Node(1); Node n2=new Node(2); Node n3=new Node(3); Node n4=new Node(4); n1.next=n2; n2.next=n3; n3.next=n4; Node temp=n1; while(temp!=null)&#123; temp=temp.next; &#125; temp=new Node(10); System.out.println(n1.next.next.next.next.val); &#125;&#125; 如果有想法大家可以在评论区交流交流。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国象棋将帅问题]]></title>
    <url>%2F2019%2F06%2F02%2F%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E5%B0%86%E5%B8%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 在中国象棋里将和帅是不能碰面的，如下图所示，当将位于d10时，帅就不能在d1,、d2、d3(如图所示)。请写一个程序，输出将、帅所有的合法位置。要求在代码中仅用一个变量。 —–题目分析—– 将帅与将的活动区域简化成一个九宫格 先不考虑一个变量这个条件，可以取两个变量i和j分别代表将和帅的位置，用两个循环遍历并比较是否在一条线上。(见代码a) 考虑一个变量这个条件，怎么用一个变量来表示将帅两个不同位置。(见代码b) 代码 代码a 12345678910111213public class Solution &#123; public static void main(String[] args) &#123; for (int i=0;i&lt;9;i++)&#123; for (int j=0;j&lt;9;j++)&#123; if (i%3==j%3)&#123; continue; &#125;else&#123; System.out.println("象棋对应的位置为："+"("+(i+1)+","+(j+1)+")"); &#125; &#125; &#125; &#125;&#125; 代码b 123456789101112public class Solution &#123; public static void main(String[] args) &#123; byte s=81; while ((s--)!=0)&#123; if ((s/9%3)==(s%9%3)) &#123; continue; &#125;else &#123; System.out.println("象棋对应位置为："+"("+(s/9+1)+","+(s%9+1)+")"); &#125; &#125; &#125;&#125; 解析： 巧用s/9和s%9，s从80到72，s/9的结果一直为8而s%9的结果是从8到0.byte s=81是为了简化程序，byte s=80是可以的，需要简单的改一下。]]></content>
      <categories>
        <category>编程之美</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序数组中的重复项]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 —–题目分析—– 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 :给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 —–代码—– 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int length=1; for(int i=1;i&lt;nums.length;i++)&#123; while(i&lt;nums.length&amp;&amp;nums[i]==nums[i-1])&#123; i++; &#125; if(i&lt;nums.length)&#123; nums[length++]=nums[i]; &#125; &#125; return length; &#125;&#125; 12执行用时 : 2 ms内存消耗 : 44 MB]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗马数字转整数]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[—–题目描述—–罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。| 字符 | 数值 || —- | :–: ||I |1 ||v|5||x|10||L|50||C|100||D|500||M|1000|—–题目分析—–罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。—–代码—– 12345678910111213141516171819202122232425262728293031class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int temp=0; for(int i=0;i&lt;s.length();i++)&#123; /** * 如果不是数组最后最后一项或者是数组倒数第二项 * 1、i为数组最后一项只有可能执行temp+=map.get(s.charAt(i));(没有下一项进行比较)为了防止数组下标越界，只能在最后加上最后一项 * 2、i为倒数第二项，如果执行判断语句后 */ if(i!=s.length()-1)&#123; if(map.get(s.charAt(i))&lt;map.get(s.charAt(i+1)))&#123; temp+=map.get(s.charAt(i+1))-map.get(s.charAt(i)); i++; &#125;else&#123; temp+=map.get(s.charAt(i)); &#125; &#125;else&#123; temp+=map.get(s.charAt(s.length()-1)); &#125; &#125; return temp; &#125;&#125; 解析： 本题是由一个标签值查找另一个签值，很容易想到Map键对值，通过key去查找value。 12执行用时 : 33 ms内存消耗 : 40 MB]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
