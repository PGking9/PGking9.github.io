<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、什么是反射java反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象的方法的功能成为java语言的反射机制。 二、反射的作用之前访问一个类的属性或方法，总是需要这个类实例化一个对象去调用，现在通过反射也可以获取类的属性和方法，并且这个机制是动态获取。JDBC访问数据库时需要加载数据库提供的驱动程序（MySQL为例），Class.forName(“com.mysql.jdbc.Driver”);即可对驱动程序包下Driver类的静态方法完成加载。 1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125; 所以常常用来编写通用性较高的代码或者框架的时候使用。 三、反射的常用对象1、Class class类的实例表示正在运行的Java应用程序中的类和接口 2、Constructor 关于类的单个构造方法的信息以及对它的访问权限 3、Field Field提供有关类或接口的单个字段的信息，以及对它的动态访问权限。 4、Method Method提供关于类或接口上单独某个方法的信息 四、Class1、对Class的一些理解 Class本身就是一个类，注意与class的区别 Class对象只能由系统建立（我们只能去获得Class对象） 一个加载的类在JVM中只会有一个Class实例 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142public class User &#123; private String name; private String sex; private int age; public User() &#123; &#125; public User(String name, String sex, int age) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat() &#123; System.out.println(&quot;我会吃东西&quot;); &#125; @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, sex=&quot; + sex + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 测试 1234567public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; User a = new User(&quot;huahua&quot;,&quot;女&quot;,13); User b = new User(&quot;mingming&quot;,&quot;男&quot;,15); Class c1 = a.getClass(); Class c2 = b.getClass(); System.out.println(c1 == c2);&#125; 结果： 1true 一个Class对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例产生 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。 2、获取Class对象方式1234567891011public static void main(String[] args) throws ClassNotFoundException &#123; //通过对象名来访问 Object中有getClass()方法 : 获得运行当前对象的Class文件对象 User u1 = new User(); Class c1 = u1.getClass(); //通过Class类中forName()方法 Class c2 = Class.forName(&quot;test1.User&quot;); //通过类名来获得 Class c3 = User.class;&#125; 3、其他12345678910public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; //通过包名.类名加载 //c1为user.class文件的对象 //u1，u2为User类的对象 Class c1 = Class.forName("test1.User"); //相当于 User user = new User（）; User u1 = (User) c1.newInstance(); User u2 = (User) c1.newInstance(); System.out.println(u1 == u2); &#125; 五、Constructor使用方法 Constructor类的实例对象代表类的一个构造方法 得到某个类的所有构造方法 1Constructor[] constructors = Class.forName("java.lang.String").getConstructors(); 得到指定的构造方法并调用 1234567891011121314public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; //获取无参构造方法 Class class1 = Class.forName("test1.User"); Constructor c1 = class1.getConstructor(); User user1 = (User) c1.newInstance(); //相当于User user = new User(); user1.eat(); //获取有参构造方法 Constructor c2 = class1.getConstructor(String.class, String.class, int.class); //相当于 User user = new User("huahua","male",20); User user2 = (User) c2.newInstance("huahua","male",20); System.out.println(user2.toString()); &#125; 六、Field使用方法 Field类代表某个类中的一个成员变量，并提供动态访问权限 实体类 12345678910111213141516171819202122232425262728293031323334353637public class Person &#123; public Person() &#123; &#125; public Person(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public String name; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void run() &#123; System.out.println("跑起来!"); &#125; @Override public String toString() &#123; return "Person [name=" + name + ", sex=" + sex + "]"; &#125;&#125; 测试 123456789101112131415161718192021222324public class FieldTest &#123; //@Test //测试公有属性 public void demo() throws Exception &#123; Class class1 = Class.forName("com.chr.reflect.Person"); Field field = class1.getField("name"); Person person = (Person)class1.newInstance(); field.set(person, "李四");//相当于 person.name = "李四"; String s = (String)field.get(person);//获得该对象属性的值 System.out.println(s); &#125; @Test //测试私有属性 public void demo_1() throws Exception &#123; Class class1 = Class.forName("com.chr.reflect.Person"); Field field = class1.getDeclaredField("sex"); Person p = (Person)class1.newInstance(); field.setAccessible(true);//开启访问私有属性的权限 field.set(p, "男"); String s = (String)field.get(p); System.out.println(s); &#125; &#125; 七、Method使用方法 Method提供关于类或接口上单独某个方法的信息 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Address &#123; private int id; private String name; private String address; private String tel; public Address() &#123; &#125; public Address(int id, String name, String address, String tel) &#123; this.id = id; this.name = name; this.address = address; this.tel = tel; &#125; @Override public String toString() &#123; return "Address [id=" + id + ", name=" + name + ", address=" + address + ", tel=" + tel + "]"; &#125; public void display() &#123; System.out.println("这是一个地址"); &#125; private void info() &#123; System.out.println("我是私有方法"); &#125; private void equalsAddress(String name) &#123; boolean flag = "李明".equals(name); if(flag == true) &#123; System.out.println("相等"); &#125;else &#123; System.out.println("不相等"); &#125; &#125;&#125; 测试 1234567891011121314151617181920public class AddressTest &#123; @Test public void demo() throws Exception &#123; Class class1 = Class.forName("com.chr.reflect.Address"); Address addr = (Address)class1.newInstance(); //公有方法 Method method1 = class1.getMethod("display", null); method1.invoke(addr, null); //私有方法 Method method2 = class1.getDeclaredMethod("info", null); method2.setAccessible(true); method2.invoke(addr, null); Method method3 = class1.getDeclaredMethod("equalsAddress", String.class); method3.setAccessible(true); method3.invoke(addr,"李明");//执行equalsAddress方法 &#125; &#125; invoke()方法的返回的Object类型为原方法的返回类型。 八、反射与new有什么不同1、new出来的对象无法调用类的私有属性和方法（只能通过get，set方法访问和赋值），反射出来的Field和Method对象则可以访问私有属性和方法。 2、在不知道类名的情况下，就无法new出一个新的对向？但是肯定有这样的疑问，不知道类名，你怎么反射啊？ 那么接下来在讲讲new和反射本质上的区别，new属于静态编译（所有需要创建的对象的代码已经写好了），而反射属于动态编译，意思就说只有到运行时他才会去获得该对象的实例，可能讲的有些抽象（也有可能讲的不太正确） 举例：spring框架是事先就写好的框架，他内部的处理并不知道用户要写哪些类，应为那是以后由用他的人来定的，这时候你还能在spring内部去new吗？所以用户在用的时候才去配置文件中配置类路径，这是一个典型反射的例子。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC的学习记录---]]></title>
    <url>%2F2019%2F10%2F12%2FJDBC%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一 、什么是JDBC1、背景介绍JDBC : Java DataBase Connectivity Java数据库连接 sun公司在1996年发布了（JDBC）API,它的为了使Java开发人员使用java连接数据库，并用结构化查询语言（SQL）完成对数据库进行增删改查（CURD）的操作。 C : 创建（Create） U : 更新（Update ) R : 读取（Retrieve） D : 删除（Delete） 2、如何与数据库连接由于业界存在许多不同的数据库，访问数据库的网络协议并不相同，所以Java在为SQL访问提供一个API的同时，也提供了一个驱动管理器，允许使用第三方的驱动程序可以连接到特定的数据库。开发人员使用Java连接数据库的过程为：根据API编写的程序与驱动管理器进行通信，而驱动管理程序通过与实际的数据库进行通信。 二、连接数据库的过程 1、加载驱动 2、获得连接 3、创建执行SQL语句对象，并且执行SQL 4、释放资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void demo() &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //1、加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2、获得连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/corporation&quot;, &quot;root&quot;, &quot;123456&quot;); //3、创建执行SQL语句对象，并且执行SQL String sql = &quot;SELECT * FROM goods WHERE price &lt; 3500&quot;; //3.1 创建执行SQL语句的对象 stmt = conn.createStatement(); //3.2 执行sql,获得数据集，存放的是数据表中的记录 rs = stmt.executeQuery(sql); while(rs.next()) &#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); Float price = rs.getFloat(&quot;price&quot;); String desp = rs.getString(&quot;desp&quot;); System.out.println(id+&quot; &quot;+name+&quot; &quot;+price+&quot; &quot;+desp); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; //4、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; rs = null; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; stmt = null; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; conn = null; &#125; &#125; &#125; 这里使用的是MySQL数据库，使用时需导入MySQL的驱动程序。 三、SQL注入漏洞1、SQL注入漏洞的由来12345678910111213141516171819202122232425262728293031323334public void test() &#123; boolean flag = login(&quot;AAA &apos; or &apos;1=1&quot;,&quot;asdgasfdg&quot;); if(flag == true) &#123; System.out.println(&quot;登陆成功&quot;); &#125;else &#123; System.out.println(&quot;登陆失败&quot;); &#125; &#125; //登录时获取用户名和密码public static boolean login(String username, String password) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; boolean flag = false; try &#123; conn = JDBCUtils.getConnection(); stmt = conn.createStatement(); //在数据库中查询 String sql = &quot;select * from login where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos;&quot;; rs = stmt.executeQuery(sql); if(rs.next()) &#123; flag = true; &#125;else &#123; flag = false; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.realease(rs, stmt, conn); &#125; return flag; &#125; 上述的例子是用户登录时，我们从前台获取用户的姓名和密码，到数据库中查询是否存在，如果使用Statement执行sql语句，就可能存在sql的注入漏洞。比如前台传来的username = “AAA ‘ or ‘1=1”；那么无论密码是否争取，查询结果都为true。 sql语句的执行条件就会变成： username = ‘AAA’ or ‘1=1 and password = ‘adgfg’;(密码随便输入的) 2、如何防范注入漏洞123456789101112131415161718192021222324252627282930313233343536public void test() &#123; boolean flag = login_2(&quot;AAA &apos; or &apos;1=1&quot;,&quot;asdgasfdg&quot;); if(flag == true) &#123; System.out.println(&quot;登陆成功&quot;); &#125;else &#123; System.out.println(&quot;登陆失败&quot;); &#125; &#125; public static boolean login_2(String username, String password) &#123; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; boolean flag = false; try &#123; conn = JDBCUtils.getConnection(); //使用？号进行占位，在传进来的变量不会在进行sql编译 String sql = &quot;select * from login where username = ? and password = ?&quot;; pstmt = conn.prepareStatement(sql); //给第一个？号设置变量内容 pstmt.setString(1, username); pstmt.setString(2, password); rs = pstmt.executeQuery(); if (rs.next()) &#123; flag = true; &#125;else &#123; flag = false; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.realease(rs, pstmt, conn); &#125; return flag; &#125; 将Statement换成PreparedStatement,再写sql语句的时候，变量用？占位，在对？进行变量赋值时，不会对该变量的内容进行sql编译。 username = “AAA ‘ or ‘1=1”它就只当作一个变量的内容，而不会编译。 四、C3P0连接池如果JSP或Servlet使用JDBC直接访问数据库中的数据，每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。数据库连接池技术是解决这个问题最常用的方法。这里使用的是C3P0连接池。 1234567891011121314151617181920212223242526272829303132333435public class JDBCUtils &#123; private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); //创建连接对象 public static Connection getConnection() throws SQLException &#123; Connection conn = null; conn = dataSource.getConnection(); return conn; &#125; //释放资源 public static void realease(Statement stmt, Connection conn) &#123; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; stmt = null; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; conn = null; &#125; &#125; &#125; 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt;&lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/corporation&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;/default-config&gt;&lt;/c3p0-config&gt; 需要导入C3P0jar包，JDBC工具类用xml文件来配置数据库连接的相关信息，xml文件命名为c3p0-config.xml,且文件需放在类加载路径下（src包下） 。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F09%2F%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E5%B9%B4%E6%9C%88%E6%97%A5%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[时间戳与年月日相互转换 1、时间戳转年月日 123456public static void main(String[] args) &#123; //获取系统当前时间的时间戳 Long time = System.currentTimeMillis(); SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;); System.out.println(ft.format(new Date(time)));&#125; 12345678910public static void main(String[] args) &#123; //十位的是以秒为单位，十三位的是以毫秒为单位 Long time = 1570604496L; //new Date()构造器中存放的是以毫秒为单位的 Date date = new Date(time * 1000); //规定时间格式 SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(ft.format(date)); &#125; 2、年月日转时间戳 123456789101112public static void main(String[] args) &#123; String time = &quot;2019-10-09 15-01-36&quot;; SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;); try &#123; //按照指定的格式将时间字符串转化成包含时间戳的Date对象 Date date = ft.parse(time); System.out.println(date.getTime()); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F10%2F03%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文介绍一些泛型的基本知识！ 1、为什么要使用泛型 使用泛型机制编写的程序代码比那些杂乱地使用Object变量，然后在进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用。 ArrayList底层的集合使用的是Object数组，可以加入任何对象。 123456789101112131415161718 public static void main(String[] args) &#123; List list = new ArrayList(); list.add(123);//没有报错 list.add(&quot;asf&quot;); //没有报错 boolean flag = false; for(int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); if (&quot;asf&quot;.equals(list.get(i))) &#123; flag = true; &#125; &#125; System.out.println(true); &#125;//输出为： 123 asf true 但是取出对象时，就需要进行强制转换。 而加入泛型后，出现不同类型后就会出现报错。 12345public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList(); list.add(123);//出现报错 list.add(&quot;asf&quot;); //没有报错 &#125; 2、泛型类 需要在类名后加这样的占位符，为了创建对象时，放入类型变量。 1234567891011121314151617181920public class NumGeneric&lt;T&gt; &#123; private T num; public void setNum(T num) &#123; this.num = num; &#125; public T getNum() &#123; return (T)num; &#125; public static void main(String[] args) &#123; NumGeneric&lt;Integer&gt; ng = new NumGeneric&lt;&gt;(); ng.setNum(2); System.out.println(ng.getNum()); &#125; &#125; 3、泛型方法 类型变量一般放在修饰符的后面（这里的是public static）的后面，返回类型的前面。 123456789public static &lt;T extends Number&gt; void genericPrint(T t) &#123; System.out.println(t); &#125; public static void main(String[] args) &#123; genericPrint(&quot;hello&quot;); //出现报错 genericPrint(123); genericPrint(0.5f); &#125; 为什么会出现报错？ 类型变量T继承了Number,所以调用该方法的变量必须是Number类及其子类。 4、类型擦除]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals与hashcode分析]]></title>
    <url>%2F2019%2F09%2F25%2Fequals%E4%B8%8Ehashcode%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[我们经常在面经中看到这样的问题，为什么重写equals方法就一定要重写hashcode方法。本文就是分析这个问题。 在阿里巴巴java开发手册中就给出了这样的规则。 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：1） 只要重写 equals，就必须重写 hashCode。2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 看下面的代码，有什么问题吗？ 1234567891011121314151617181920212223242526272829import java.util.HashMap;import java.util.Map;public class Five &#123; public static class Person&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; &#125; public static void main(String[] args) &#123; Map&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(new Person(&quot;sisi&quot;, 18), 9); map.put(new Person(&quot;lili&quot;, 12), 2); map.put(new Person(&quot;lili&quot;, 12), 1); System.out.println(map.toString()); System.out.println(map.get(new Person(&quot;sisi&quot;, 18))); System.out.println(map.get(new Person(&quot;lili&quot;, 12))); &#125; &#125; 运行后的结果为： 123&#123;com.chr.binarysearch.Five$Person@7852e922=1, com.chr.binarysearch.Five$Person@15db9742=9, com.chr.binarysearch.Five$Person@6d06d69c=2&#125;nullnull 我们不难看出new Person(“lili”, 12)这个对象作为key，竟然加入到HashMap中两次，违背了HashMap中key是唯一的原则。我们可以插入System.out.println(new Person(“lili”, 12).hashcode());来获得两次添加到HashMap中对象的hashcode的值。 122018699554118352462 虽然对象相同，但是hashcode值不同，这也解释了通过对象获取value值为null。 那么该如何保证自定义类对象作为key的唯一性？ 重写equals方法和hashcode方法。 在java核心技术 卷1中给出了编写一个完美的equals方法的建议： 12345678910111213141516171819public boolean equals(Object otherObj)&#123; 1)检测this与otherObj是否引用同一个对象： if(this == otherObj)&#123; return true; &#125; 2)检测otherObj是否为null，如果为null，返回false。 if(otherObj == null)&#123; return false; &#125; 3)比较this与otherObj是否属于同一个类。 if(getClass() != otherObj.getClass())&#123; return false; &#125; 4)将otherObj转换成相应的类型变量： ClassName other = (ClassName)otherObj; 5)开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。 return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2);&#125; 这是我自己重写的equals方法 12345678910111213141516public boolean equals(Object otherObj) &#123; if(this == otherObj) &#123; return true; &#125; if(otherObj == null) &#123; return false; &#125; if(!(otherObj instanceof Person)) &#123; return false; &#125; Person other = (Person)otherObj; return Objects.equals(name, other.name) &amp;&amp; age == other.age; &#125; &#125; 之所以用objects.equals(name,other.name);防止空指针异常。 重写hashcode方法 123public int hashCode() &#123; return Objects.hash(name,age); &#125;]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序数组转换为二叉搜索树]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 —–题目分析—– 二叉搜索树的中序遍历就是一个按照升序排列的有序数组，且根节点的 下标为（start+end）/2，start:数组第一个元素的下标 end:数组最后一个元素的下标 —–代码—– 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums==null)&#123; return null; &#125;else&#123; TreeNode temp=creatBinaryTree(nums,0,nums.length-1 ); return temp; &#125; &#125; public TreeNode creatBinaryTree(int[] nums,int start,int end)&#123; if(start&gt;end)&#123; return null; &#125; if(start==end)&#123; return new TreeNode(nums[start]); &#125; int mid=(start+end)/2; TreeNode root=new TreeNode(nums[mid]); root.left=creatBinaryTree(nums,start,mid-1); root.right=creatBinaryTree(nums,mid+1,end); return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[—–题目描述—–在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 —–题目分析—–1、这是一个有序的数组，可以通过数组的每行的最后一个值与目标值进行比较，如果目标值等于该值，直接返回。如果大于该值，进入下一行。如果小于该值，循环遍历查找。 2、需判断数组是否为空，特别注意[[]]这个数组。 —–代码—–1234567891011121314151617181920212223public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array.length==0||array[0].length==0)&#123; return false; &#125; for(int i=0;i&lt;array.length;i++)&#123; if(array[i][array[i].length-1]==target)&#123; return true; &#125;else&#123; if(array[i][array[i].length-1]&lt;target)&#123; continue; &#125;else&#123; for(int j=0;j&lt;array[i].length-1;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false; &#125;&#125; 运行时间：181ms 占用内存：17432k]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中两种比较器的实现]]></title>
    <url>%2F2019%2F07%2F20%2Fjava%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[—–比较器的两种实现方式—–在我们使用数组或容器的时候，经常需要使用排序，特别是根据需求自定义排序，Java给了我们两种比较器实现的接口。 一、Comparable接口它 是java.lang包下的一个接口，需要实现int compareTo(T o)方法 主代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class student implements Comparable&lt;student&gt;&#123; private String name; private int age; public student(int age) &#123; this.age = age; &#125; public student(String name, int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "我的名字是："+name+"我的年龄是：" + age; &#125; @Override public int compareTo(student o) &#123; int num=this.name.length()-o.name.length(); int num1=num==0?(this.name).compareTo(o.name):num; int num2=num1==0?this.age-o.age:num1; return num2; &#125;&#125; 测试代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; List&lt;student&gt; list = new ArrayList&lt;&gt;(); student s1=new student("LiLi",12); student s2=new student("HuaHua",9); student s3=new student("MingMing",23); student s4=new student("MeiMei",17); list.add(s1); list.add(s2); list.add(s3); list.add(s4); Collections.sort(list); Iterator&lt;student&gt; it=list.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 二、Comparator接口主代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class student&#123; private String name; private int age; public student(int age) &#123; this.age = age; &#125; public student(String name, int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "我的名字是："+name+"我的年龄是：" + age; &#125;&#125;//Comparator接口的实现类public class StudentComparator implements Comparator&lt;student&gt; &#123; public int compare(student s1, student s2) &#123; int num=s1.getName().length()-s2.getName().length(); int num1=num==0?s1.getName().compareTo(s2.getName()):num; int num2=num1==0?s1.getAge()-s2.getAge():num1; return num2; &#125;&#125; 测试代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; List&lt;student&gt; list = new ArrayList&lt;&gt;(); student s1=new student(&quot;LiLi&quot;,12); student s2=new student(&quot;HuaHua&quot;,9); student s3=new student(&quot;MingMing&quot;,23); student s4=new student(&quot;MeiMei&quot;,17); list.add(s1); list.add(s2); list.add(s3); list.add(s4); Collections.sort(list, new StudentComparator()); Iterator&lt;student&gt; it=list.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 三、比较1、Comparable是属于java.lang包下的接口，而Comparator是属于java.util包下的接口。 2、实现方式不同，Comparable接口主类（实现需求的类）可以直接实现，而不需要重新创建新的实现类，而Comparator接口需要创建新的实现类。 3、测试类的调用方式不同，Comparable接口使用的是 Collections.sort(list); 而Comparator接口使用的是 Collections.sort(list, new StudentComparator()); 4、前三点都是不同点，第四点是相同点。怎么判断正序或反序。 如果this.age&gt;o.age(this.age-o.age&gt;0)的情况下，返回的值为正值，即按正序排列，返回的值为负值，即按反序排列。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F07%2F14%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[—–题目描述—–给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 —–题目分析—–1、两个非空链表不同时为空。 2、因为是加法必须要考虑进位，且进位的可能性只有两种0或1。 3、一个链表只要有头节点就能将其表示出来 4、得到的新链表必须有pre和cur两个节点共同完成。 代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pre=new ListNode(0); ListNode p=l1; ListNode q=l2; ListNode cur=pre; int carry=0; while(p!=null||q!=null)&#123; int x=p!=null?p.val:0; int y=q!=null?q.val:0; int sum=x+y+carry; carry=sum/10; cur.next=new ListNode(sum%10); cur=cur.next; if(p!=null)&#123; p=p.next; &#125; if(q!=null)&#123; q=q.next; &#125; &#125; if(carry==1)&#123; cur.next=new ListNode(1); &#125; return pre.next; &#125;&#125; 注意:为什么返回的是pre.next(应为其指向的是链表的第一节点，值为两个链表节点和的第一个值，pre节点的值为0)，而为什么只使用cur一个节点？（cur在while循环中指向的节点早已偏离了第一个节点）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表一个有趣的问题]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 在学习单链表的时候发现一个有趣的问题，看下面的代码一与代码二，在逻辑上似乎相同，但是执行的结果却不相同，究竟是为什么？ 代码一： 12345678910111213141516171819public class SingleLinkedList &#123; public static void main(String[] args) &#123; Node n1=new Node(1); Node n2=new Node(2); Node n3=new Node(3); Node n4=new Node(4); n1.next=n2; n2.next=n3; n3.next=n4; Node temp=n1; while(temp.next!=null)&#123; temp=temp.next; &#125; temp.next=new Node(10); System.out.println(n1.next.next.next.next.val); &#125;&#125; 代码二： 12345678910111213141516171819public class SingleLinkedList &#123; public static void main(String[] args) &#123; Node n1=new Node(1); Node n2=new Node(2); Node n3=new Node(3); Node n4=new Node(4); n1.next=n2; n2.next=n3; n3.next=n4; Node temp=n1; while(temp!=null)&#123; temp=temp.next; &#125; temp=new Node(10); System.out.println(n1.next.next.next.next.val); &#125;&#125; 如果有想法大家可以在评论区交流交流。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国象棋将帅问题]]></title>
    <url>%2F2019%2F06%2F02%2F%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E5%B0%86%E5%B8%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 在中国象棋里将和帅是不能碰面的，如下图所示，当将位于d10时，帅就不能在d1,、d2、d3(如图所示)。请写一个程序，输出将、帅所有的合法位置。要求在代码中仅用一个变量。 —–题目分析—– 将帅与将的活动区域简化成一个九宫格 先不考虑一个变量这个条件，可以取两个变量i和j分别代表将和帅的位置，用两个循环遍历并比较是否在一条线上。(见代码a) 考虑一个变量这个条件，怎么用一个变量来表示将帅两个不同位置。(见代码b) 代码 代码a 12345678910111213public class Solution &#123; public static void main(String[] args) &#123; for (int i=0;i&lt;9;i++)&#123; for (int j=0;j&lt;9;j++)&#123; if (i%3==j%3)&#123; continue; &#125;else&#123; System.out.println("象棋对应的位置为："+"("+(i+1)+","+(j+1)+")"); &#125; &#125; &#125; &#125;&#125; 代码b 123456789101112public class Solution &#123; public static void main(String[] args) &#123; byte s=81; while ((s--)!=0)&#123; if ((s/9%3)==(s%9%3)) &#123; continue; &#125;else &#123; System.out.println("象棋对应位置为："+"("+(s/9+1)+","+(s%9+1)+")"); &#125; &#125; &#125;&#125; 解析： 巧用s/9和s%9，s从80到72，s/9的结果一直为8而s%9的结果是从8到0.byte s=81是为了简化程序，byte s=80是可以的，需要简单的改一下。]]></content>
      <categories>
        <category>编程之美</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序数组中的重复项]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[—–题目描述—– 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 —–题目分析—– 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 :给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 —–代码—– 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int length=1; for(int i=1;i&lt;nums.length;i++)&#123; while(i&lt;nums.length&amp;&amp;nums[i]==nums[i-1])&#123; i++; &#125; if(i&lt;nums.length)&#123; nums[length++]=nums[i]; &#125; &#125; return length; &#125;&#125; 12执行用时 : 2 ms内存消耗 : 44 MB]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗马数字转整数]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[—–题目描述—–罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 v 5 x 10 L 50 C 100 D 500 M 1000 —–题目分析—–罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 —–代码—–12345678910111213141516171819202122232425262728293031class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int temp=0; for(int i=0;i&lt;s.length();i++)&#123; /** * 如果不是数组最后最后一项或者是数组倒数第二项 * 1、i为数组最后一项只有可能执行temp+=map.get(s.charAt(i));(没有下一项进行比较)为了防止数组下标越界，只能在最后加上最后一项 * 2、i为倒数第二项，如果执行判断语句后 */ if(i!=s.length()-1)&#123; if(map.get(s.charAt(i))&lt;map.get(s.charAt(i+1)))&#123; temp+=map.get(s.charAt(i+1))-map.get(s.charAt(i)); i++; &#125;else&#123; temp+=map.get(s.charAt(i)); &#125; &#125;else&#123; temp+=map.get(s.charAt(s.length()-1)); &#125; &#125; return temp; &#125;&#125; 解析： 本题是由一个标签值查找另一个签值，很容易想到Map键对值，通过key去查找value。 12执行用时 : 33 ms内存消耗 : 40 MB]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
